<img width="80%" src="https://velog.velcdn.com/images/soopy368/post/1eba5f07-d2f3-4239-abd5-627b9eff7008/image.png" />

GET과 POST는 `HTTP 메서드`로 클라이언트에서 `서버에 정보를 요청`할 때 사용한다. 사용하려는 목적에 맞게 HTTP 통신을 제대로 사용할 수 있도록 두 메서드의 차이에 대해서 자세히 알아보자.

## GET 방식

> 서버로부터 **정보를 요청**할 때 사용되는 HTTP 메서드이다.

#### 1. 요청할 때 필요한 데이터를 Body에 담지 않고, 쿼리 스트링을 통해 전송한다.

- 예: www.example.com/resources?name1=value1&name2=value2
- 파라미터에 내용이 노출되기 때문에 민감한 데이터를 다룰 때 GET 요청을 사용하지 않는다.

#### 2. 데이터가 담기는 곳: HTTP 패킷 Header

#### 3. GET 요청은 브라우저 히스토리에 남는다.

#### 4. GET 요청은 길이 제한이 있다.

#### 5. 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있다.

- js, css, 이미지 같은 정적 컨텐츠는 데이터 양이 크고, 변경될 일이 적어서 반복해서 요청을 보낼 필요가 없다. 그래서 프론트엔드 개발을 하다보면 `정적 컨텐츠`가 `캐시`되어 컨텐츠를 변경해도 내용이 바뀌지 않는 경우가 종종 발생한다.
  (웹뷰 환경에서 개발할 때 브라우저 캐시가 남아있는 경우를 자주 발견했었다! 분명 배포를 했는데 같은 화면이 나와서 오류인줄 알고 코드를 다시 점검했던 경험이 있다..) 이 때는 브라우저의 캐시를 지워주면 서버에 요청을 보내게 된다.
  <br>
- GET을 통해 서버에 리소스를 요청할 때 `웹 캐시가 요청을 가로채서` 서버로부터 리소스를 다시 다운로드 하는 대신 `리소스의 복사본을 반환`한다. HTTP 헤더에서 `cache-control 헤더`를 통해 `캐시 옵션`을 지정할 수 있다.

<br>

## POST 방식

> 정보를 **생성/업데이트**하기 위해 서버에 데이터를 보내는 HTTP 메서드이다.

#### 1. GET과 달리 전송할 데이터를 HTTP 메세지의 Body에 담아서 전송한다.

- `Body의 타입`은 요청 `헤더의 Content-Type`에서 설정해주어야 한다. 타입을 선언하지 않으면 서버는 내용이나 url에 포함된 리소스의 확장자명으로 데이터 타입을 유추한다. 알 수 없는 경우에는 application/octet-stream으로 요청을 처리한다.
  <br>
- 데이터가 Body로 전송되고 내용이 눈에 보이지 않아서 GET 요청보다 보안적인 면에서 더 안전하다고 생각할 수 있겠지만, 크롬 개발자 도구 등으로 확인할 수 있기 때문에 민감한 정보는 반드시 `암호화가 필요`하다.

#### 2. 데이터가 담기는 곳: HTTP 패킷 Body

#### 3. POST 요청은 캐시되지 않는다.

#### 4. POST 요청은 브라우저 히스토리에 남지 않는다.

#### 5. POST 요청은 데이터 길이에 제한이 없다.

<br>

## GET과 POST의 차이점

- **사용목적**: `GET`은 서버의 리소스에서 `데이터를 요청`할 때, `POST`는 서버의 리소스를 `새로 생성하거나 업데이트` 할 때 사용된다.

- DB로 비유하면 GET은 SELECT에 가깝고, POST는 CREATE에 가깝다.
- **요청에 body 유무**: GET은 URL 파라미터에 데이터를 담아 보내기 때문에 HTTP 메세지에 body가 없다. `POST`는 `body에 데이터를 담아보낸다.`
- **멱등성(idempotent)**: `GET` 요청은 `멱등`이고 POST는 멱등이 아니다.

### 멱등이란?

멱등의 사전적 의미는 `연산을 여러 번 적용`하더라도 `결과가 달라지지 않는 성질`을 뜻한다. GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것이다. 반대로 POST는 리소스를 생성하거나 업데이트할 때 사용되기 때문에 멱등이 아니라고 볼 수 있다. (POST로 서버 리소스가 변경될 수 있다.)
