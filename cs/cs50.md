# [CS50 강의](https://www.boostcourse.org/cs112/joinLectures/41307) 정리

## 1. 컴퓨팅 사고

### 정보 표현의 기본 장치

- 컴퓨터에는 트랜지스터라고 불리는 굉장히 많은 스위치가 있고 on/off 상태를 통해 0과1을 표현합니다.
- ASCII: 문자를 숫자로 표현
- Unicode: ASCII로는 표현하지 못하는 문자를 표현

### 알고리즘의 표현

- 의사코드: 사람이 사용하는 언어를 통해 알고리즘의 논리적 절차를 작성한 코드

<br />

## 2. C언어

- 사용자 정의 함수이기 때문에 출력 형태와 입력 형태를 명시할 수 있습니다.

```c
// 사용자 정의 함수의 형태
출력형태 함수명 (입력형태)

void hello(void); // c언어에서는 상단에 사용자 정의 함수를 정의해주어야 합니다.
int main(void){
	hello();
}

void hello(void){
	printf("Hello World!")
}
```

### C언어 자료형 정리

| 자료형 | placeholder | 크기  |
| ------ | ----------- | ----- |
| char   | %c          | 1byte |
| int    | %i          | 4byte |
| float  | %f          | 4byte |
| long   | %li         | 8byte |
| double | %f          | 8byte |

### 컴파일러

소스 코드를 컴퓨터가 이해할 수 있도록 2진수로 작성된 머신 코드로 변환해주는 프로그램

### 컴파일 방법

- $clang hello.c: hello.c 소스코드를 머신코드로 컴파일 하기 위한 명령어
- $make hello: 컴파일 실행
- ./hello.out: 프로그램 실행

### 하드웨어의 한계

- RAM
- 오버플로우: 저장 가능한 비트 수를 초과할 경우 발생하는 문제

<br />

## 3. 배열

### 컴파일링 4단계

- 전처리: 소스 내의 헤더 파일을 #include에 포함합니다. (c소스 코드 형태)
- 컴파일: c코드를 어셈블리어로 변환합니다.
- 어셈블링: 어셈블리 코드를 오브젝트 코드(기계어)로 변환합니다. (0과 1의 형태)
- 링크: 소스코드 내에 라이브러리가 있다면 수행하고 하나의 오브젝트 파일로 합칩니다.

### 명령행 인자

- int main(int argc, string argv[])
  - argc: main 함수가 받게 될 입력의 개수
  - argv[]: 그 입력이 포함된 string 배열
    - argv[0]: 프로그램 명
    - 프로그램 명 외의 문자열이 입력되면 argv[1]이 됩니다.

```c
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

> 프로그램을 ‘test.c’로 저장하고 컴파일한 뒤, ./test로 실행하면 argc 값이 프로그램 이름 하나뿐이기에 ‘hello, world’ 출력

> ‘./test Tom’으로 실행해보면 ‘hello, Tom’ 출력

<br />

## 4. 알고리즘

### 처리 시간

- BigO: 실행 시간의 상한을 표현 (최악의 경우) / Big Ω: 실행시간의 하한 표 (최고의 경우)
- 빠른 처리 순서(하한 기준): **이진 검색 - 선형 검색 - 버블 정렬 - 병합 정렬 - 선택 정렬**
  - 이진검색 O(log n): 정렬 되어있는 배열에서, 중간 인덱스의 값과 비교하여 그보다 작은 또는 큰 인덱스로 이동을 반복
  - 선형검색 O(n): 원하는 원소가 발견될 때까지 처음부터 마지막까지 차례대로 검색
  - 버블정렬 O(n): 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬
  - 병합정렬 O(nlogn): 원소가 한 개가 될 때까지 데이터를 반으로 나누다가 다시 합쳐나가며 정렬
  - 선택정렬 O(n^2): 가장 작은 값을 찾아서 첫 번째 원소와 스왑하고 그 다음 작은 값을 찾아서 두 번째 원소와 스왑하는 과정을 반복
