<img width="400px" src="https://velog.velcdn.com/images/soopy368/post/426525a0-26ee-4dce-bae8-61df6209f9d4/image.png" />

## 클로저란 무엇인가?

### 정확한 정의

- 클로저란, 함수와 함수가 선언되었을 때의 렉시컬 환경의 조합이다.

### 😇 쉽게 이해하기

- 클로저란, 자신이 선언된 당시의 환경을 기억하는 함수이다.

- 클로저란, 생명주기가 끝난 외부 함수의 식별자에 접근할 수 있는 내부 함수이다.

<br />

## 어떻게 동작하나요?

### 선행 지식

- **스코프**
  - 변수에 접근할 수 있는 범위, JS에는 전역 스코프와 지역 스코프 타입이 있다.
- **렉시컬 스코프**

  - 함수를 어디에 `선언`하였는지에 따라 `상위 스코프가 결정`된다. 이를 정적 스코프라고 부르기도 한다.

    <br />

  ```jsx
  var x = 1;

  function foo() {
    var x = 10;
    bar();
  }

  function bar() {
    console.log(x);
  }

  foo(); // 1
  bar(); // 1
  ```

  1. bar()에서 참조하는 x 변수는 bar()의 상위 스코프가 무엇인지에 따라 결정된다.
  2. bar()는 전역에 선언되었으므로, 상위 스코프는 전역 스코프가 된다.
  3. 따라서 bar()의 x는 전역에 선언된 x 변수를 참조하게 된다.

<br />

### 동작 원리

- 클로저는 자신이 생성될 때의 환경(=렉시컬 스코프)을 기억하는 함수이다.
- 자바스크립트의 모든 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는다. 이곳에 렉시컬 스코프에 대한 참조값이 저장된다.
- 함수 본문에서 `[[Environment]]`를 사용해서 외부 함수의 변수에도 접근할 수 있게 된다.

### 😇 쉽게 이해하기

- 클로저 = 함수 + 렉시컬 스코프
- JS의 모든 함수는 자신이 생성된 환경의 주소를 저장하고 있다. 즉, 상위 스코프의 주소를 가지고 있다.
- 함수 본문에서 상위 스코프의 주소를 참조하여 외부 함수의 변수에도 접근할 수 있게 된다.

<br />

### 코드로 이해해봐요

```jsx
const outer = () => {
  let x = 10; // '자유 변수' 라고 한다.

  // 클로저
  const inner = (y) => {
    x = x + y;
    console.log(x);
  };

  return inner;
};

const addFunc = outer();
addFunc(5); // 15
addFunc(10); // 25
```

- `inner의 x`는 렉시컬 스코프에 의해 `outer의 지역변수 x`를 참조하고 있다.
- 그리고 outer는 `const addFunc = outer();`구문에서 호출된 후 콜스택에서 제거된다.
- 하지만 `내부 함수가 유효`한 상태에서는 외부 함수가 종료되어도 `[[Environment]]`에서 `렉시컬 스코프를 참조`하고 있기 때문에 외부 함수의 x 변수를 참조할 수 있다.
- 여기서 내부 함수를 `클로저`라고 한다.

<br />

## 왜 사용하는 걸까요?

### 1. 정보 은닉

변수 값을 은닉할 수 있다. 클래스 기반 언어의 private 키워드를 흉내낼 수 있다.

### 2. 전역 변수 사용 억제

전역 변수를 대체하여 오류를 피하는 안정성을 증가시킬 수 있다.

### 3. 상태 유지

현재 상태를 기억하고 변경된 최신 상태를 유지할 수 있다.

<br />

## 사용 사례 (debounce)

연이어 호출되는 함수들 중 가장 마지막 함수만 실행되게 한다.

```jsx
function debounce(callback, delay) {
  let timer = null; // timer에 대한 정보는 상위 스코프에 존재한다.
  return (...args) => {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      callback(...args);
    }, delay);
  };
}

// debounced는 debounce가 적용된 콜백 함수이다.
const debounced = debounce((text) => console.log(text), 500);
```

### 코드 동작 과정

1. 함수를 호출한다. 함수는 setTimeout으로 인해 n초 뒤에 실행된다.
2. 다시 함수를 호출한다. clearTimeout을 통해 기존 timer를 초기화하고 다시 setTimeout을 적용한다.
3. 설정한 시간 동안 다시 함수를 호출하지 않으면 콜백 함수가 실행된다.

### 클로저를 적용한 이유

- 함수가 호출되면서 timer가 초기화 되고 다시 설정되는 과정을 반복한다.
- `타이머`에 대한 정보를 `계속 기억`하려면, 타이머에 대한 정보는 실제 디바운스가 실행될 함수와 `다른 스코프`에 있어야 한다.
- 같은 스코프에 있다면 해당 함수가 종료되었을 때 타이머 또한 사라질 것이기 때문이다.
- 그렇기 때문에 `상위 스코프`에 타이머 정보를 저장하여 `타이머 정보가 유지`되도록 클로저 형태로 구현되어야 한다.

<br />

## 주의할 점

- 클로저를 사용하면 `메모리` 측면에서 `손해`를 볼 수 있다.
- 내부 함수가 외부 함수의 변수를 참조하고 있기 때문에, 외부 함수의 실행이 끝나더라도 가비지 콜렉터에 의해 메모리가 해제되지 않는다.
- 따라서 클로저를 할당한 변수에 null을 할당해줌으로써 메모리를 해제시킬 수 있다.

```jsx
const outerFunc = () => {
  let x = 10;

  // 클로저
  const innerFunc = (y) => {
    x = x + y;
    console.log(x);
  };

  return innerFunc;
};

let addFunc = outerFunc();
addFunc(5);
// 메모리 해제
addFunc = null;
```

<br />

## 추가 설명

- 클로저는 Javascript만의 고유 개념은 아니고, 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 특징 중 하나입니다.
- 렉시컬 스코프란 선언된 위치에 따라 상위 스코프가 결정되는 정적 스코프이다.
- 이와 반대로 `동적 스코프`는 함수를 `호출한 위치`에 따라 상위 스코프가 결정된다. 다만, 대부분의 프로그래밍 언어는 모두 정적 스코프를 따른다.
